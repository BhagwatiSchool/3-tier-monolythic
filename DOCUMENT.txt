================================================================================
RESOURCE MANAGEMENT DASHBOARD - COMPLETE TECHNICAL DOCUMENTATION
================================================================================

Version: 1.0.0
Last Updated: November 25, 2025
Status: Production Ready

================================================================================
TABLE OF CONTENTS
================================================================================

1. EXECUTIVE SUMMARY
2. SYSTEM ARCHITECTURE (3-TIER)
3. TECHNOLOGY STACK
4. DATA MODELS & DATABASE SCHEMA
5. API SPECIFICATIONS
6. AUTHENTICATION & AUTHORIZATION FLOW
7. FRONTEND ARCHITECTURE
8. BACKEND ARCHITECTURE
9. DEPLOYMENT STRATEGIES
10. PERFORMANCE & SCALABILITY
11. SECURITY CONSIDERATIONS
12. MONITORING & LOGGING
13. DISASTER RECOVERY
14. MAINTENANCE & TROUBLESHOOTING

================================================================================
1. EXECUTIVE SUMMARY
================================================================================

WHAT IS THIS APPLICATION?
Resource Management Dashboard is a professional, enterprise-grade web application
designed for IT operations teams, cloud infrastructure managers, and DevOps 
professionals to manage cloud resources centrally.

WHO USES IT?
- Cloud operations teams managing Azure/AWS resources
- DevOps engineers monitoring infrastructure
- System administrators managing user access
- Technical managers overseeing resource allocation

KEY CAPABILITIES:
✓ Multi-user authentication with JWT tokens
✓ Role-based access control (Admin/User)
✓ Create, read, update, delete (CRUD) operations for resources
✓ Real-time resource monitoring
✓ Theme customization (Light/Dark mode)
✓ Mobile-responsive interface
✓ Azure SQL or SQLite database support
✓ Professional security features

WHY 3-TIER ARCHITECTURE?
The 3-tier architecture separates concerns:
- Tier 1 (Presentation): User interface, client interactions
- Tier 2 (Business Logic): Application logic, authentication, validation
- Tier 3 (Data): Database, persistent storage

Benefits:
- Scalability: Each tier can scale independently
- Maintainability: Changes isolated to specific tier
- Reusability: Backend API can serve multiple frontends
- Security: Business logic centralized on secure backend
- Performance: Optimized caching at each layer

================================================================================
2. SYSTEM ARCHITECTURE (3-TIER)
================================================================================

TIER 1: PRESENTATION LAYER (Frontend)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Technology Stack:
- React 18.2 (UI framework)
- TypeScript (type-safe JavaScript)
- Vite 5 (build tool, <2s dev startup)
- Tailwind CSS (utility-first CSS)
- Shadcn UI (accessible component library)
- TanStack Query (data fetching/caching)
- React Router v6 (client-side routing)
- Sonner (toast notifications)
- Lucide React (icons)

Responsibilities:
✓ Render UI based on React components
✓ Handle user interactions (clicks, form submissions)
✓ Manage client-side state (authentication, theme)
✓ Cache API responses to reduce server load
✓ Validate user input before sending to backend
✓ Display real-time data updates
✓ Handle offline scenarios gracefully

Entry Point:
- frontend/src/main.tsx: Application entry
- frontend/src/App.tsx: Root component
- frontend/src/pages/: Page-level components
- frontend/src/components/: Reusable UI components

Key Components:
┌─ Authentication Context (contexts/AuthContext.tsx)
│  └─ Manages user session, tokens, login/logout
├─ Dashboard Page (pages/Dashboard.tsx)
│  └─ Resource statistics, welcome message
├─ Resources Page (pages/Resources.tsx)
│  └─ List, create, update, delete resources
├─ User Management Page (pages/UserManagement.tsx)
│  └─ Admin panel for user role management
├─ Settings Page (pages/Settings.tsx)
│  └─ Profile, theme, resource creation
└─ Layout Component (components/Layout.tsx)
   └─ Navigation, sidebar, theme toggle

HTTP Communication:
- Axios HTTP client (lib/api.ts)
- Base URL: http://localhost:8000 (dev) / https://yourdomain.com (prod)
- All requests include JWT token in Authorization header
- CORS headers handled by backend

State Management:
- TanStack Query for server state (API data)
- React Context for client state (auth, theme)
- Local state with useState for UI
- No Redux/Zustand needed - Query handles caching

Build Process:
npm run build
→ TypeScript compilation (tsc)
→ Vite bundling & minification
→ Output: frontend/dist/public/
→ Result: 3 files (HTML, CSS, JS)
→ Size: ~520KB minified, ~160KB gzipped

Development Mode:
npm run dev
→ Vite dev server on port 5000
→ HMR (Hot Module Replacement) enabled
→ Proxy to backend on :8000/api
→ Watches file changes, auto-refresh

Performance Optimizations:
- Code splitting: Components lazy-loaded
- Tree-shaking: Unused code removed
- Minification: 65% size reduction
- Gzipping: 69% size reduction
- Caching: Images, CSS, JS cached by browser

Mobile Responsiveness:
- Mobile-first approach (320px+)
- Responsive breakpoints: sm (640px), md (768px), lg (1024px)
- Touch-optimized buttons (44px+ tap targets)
- Flexible layouts with Tailwind (flex-col, sm:flex-row)
- Viewport meta tag for proper scaling

================================================================================

TIER 2: APPLICATION LAYER (Backend)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Technology Stack:
- FastAPI 0.104 (modern Python web framework)
- Uvicorn 0.24 (ASGI server)
- SQLAlchemy 2.0 (ORM)
- Pydantic 2.0 (data validation)
- python-jose (JWT tokens)
- passlib (password hashing)
- bcrypt (password encryption)

Server Configuration:
- Host: 0.0.0.0 (all interfaces)
- Port: 8000 (configurable)
- Workers: 1 (development), 4+ (production)
- Reload: True (development), False (production)
- Log Level: INFO (configurable)

Responsibilities:
✓ Authentication (login, register, token validation)
✓ Authorization (role-based access control)
✓ Business logic (resource management)
✓ Data validation (Pydantic schemas)
✓ Database operations (SQLAlchemy ORM)
✓ Error handling (proper HTTP status codes)
✓ CORS handling (cross-origin requests)
✓ Rate limiting (optional)
✓ Logging (application events)

Directory Structure:
backend/
├── app/
│   ├── __init__.py
│   ├── main.py (FastAPI app initialization)
│   ├── api/ (API endpoints)
│   │   ├── auth.py (Authentication routes)
│   │   ├── users.py (User management routes)
│   │   ├── resources.py (Resource CRUD routes)
│   │   └── theme.py (Theme routes)
│   ├── core/ (Configuration)
│   │   ├── config.py (Settings class)
│   │   ├── security.py (JWT, password hashing)
│   │   └── constants.py (Application constants)
│   ├── db/ (Database)
│   │   ├── base.py (SQLAlchemy base)
│   │   ├── session.py (Database session)
│   │   ├── init_db.py (Database initialization)
│   │   └── super_user_seed.py (Admin user creation)
│   ├── models/ (SQLAlchemy models)
│   │   ├── user.py (User model)
│   │   ├── resource.py (Resource model)
│   │   └── theme.py (Theme model)
│   └── schemas/ (Pydantic schemas)
│       ├── user.py (User request/response)
│       ├── resource.py (Resource request/response)
│       └── theme.py (Theme request/response)
├── data/ (SQLite database file, .gitignored)
│   └── app.db
├── requirements.txt (Python dependencies)
├── run.py (Application entry point)
└── .env.example (Configuration template)

API Endpoints (RESTful):

Authentication:
POST /api/auth/register       - User registration
POST /api/auth/login          - User login
POST /api/auth/refresh        - Refresh token

Users:
GET  /api/users/me            - Current user profile
PUT  /api/users/me            - Update profile
GET  /api/users               - List all users (Admin)
PUT  /api/users/{id}/role     - Change user role (Admin)
DELETE /api/users/{id}        - Delete user (Admin)

Resources:
GET  /api/resources           - List resources
POST /api/resources           - Create resource
GET  /api/resources/{id}      - Get resource
PUT  /api/resources/{id}      - Update resource
DELETE /api/resources/{id}    - Delete resource

Theme:
GET  /api/theme               - Get user theme
PUT  /api/theme               - Update theme

Health:
GET  /api/health              - API status

Request/Response Example:

LOGIN REQUEST:
POST /api/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "securepassword123"
}

LOGIN RESPONSE:
HTTP 200 OK
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "display_name": "John Doe",
    "role": "user"
  }
}

CREATE RESOURCE REQUEST:
POST /api/resources
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "icon": "server",
  "title": "Web Server",
  "resource_name": "web-server-01",
  "description": "Production web server",
  "status": "Running",
  "region": "East US"
}

CREATE RESOURCE RESPONSE:
HTTP 201 Created
{
  "id": 1,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "icon": "server",
  "title": "Web Server",
  "resource_name": "web-server-01",
  "description": "Production web server",
  "status": "Running",
  "region": "East US",
  "created_at": "2025-11-25T10:30:00Z"
}

Authentication Flow:
1. User submits credentials (email, password)
2. Backend verifies email exists in database
3. Backend compares password hash (bcrypt)
4. If valid: Generate JWT token with 30-min expiration
5. Return token to client
6. Client stores token in memory (not localStorage for security)
7. All subsequent requests include token in Authorization header
8. Backend validates token before processing request
9. If token expired: Return 401, client redirects to login

Error Handling:
HTTP 400 - Bad Request (invalid input)
HTTP 401 - Unauthorized (auth required/invalid token)
HTTP 403 - Forbidden (insufficient permissions)
HTTP 404 - Not Found (resource doesn't exist)
HTTP 500 - Server Error (internal error)

Error Response Format:
{
  "detail": "Error message describing what went wrong"
}

CORS Configuration:
- Allows requests from: Frontend domain(s)
- Methods: GET, POST, PUT, DELETE, OPTIONS
- Headers: Content-Type, Authorization
- Credentials: Enabled (for cookies)

Rate Limiting:
- Optional: Configured via environment variable
- Rate: X requests per minute per IP
- Purpose: Prevent abuse, DDoS protection

================================================================================

TIER 3: DATA LAYER (Database)
━━━━━━━━━━━━━━━━━━━━━━━━━━━

Database Support:
- Development: SQLite (file-based, zero-config)
- Production: Azure SQL (cloud-hosted, HA)

Database Selection Logic:
if AZURE_SQL_SERVER environment variable set:
  → Use Azure SQL (production)
else:
  → Use SQLite (development)

SQLite Configuration:
- File: backend/data/app.db
- Location: Local file system
- Benefits: No server setup, easy development
- Drawbacks: Not suitable for production scale
- Backup: Copy app.db file
- Reset: Delete app.db, restart server

Azure SQL Configuration:
- Server: your-server.database.windows.net
- Port: 1433
- Authentication: Username/password
- Benefits: Cloud-hosted, HA, backups, scaling
- Drawbacks: Monthly cost, setup complexity
- Connection String:
  mssql+pyodbc://user:password@server/database?driver=ODBC+Driver+17

Connection String Format:
SQLite: sqlite:///./backend/data/app.db
Azure SQL: mssql+pyodbc://user:pass@server.database.windows.net/db

SQLAlchemy ORM:
- Eliminates manual SQL writing
- Automatic SQL generation based on models
- Type safety with Python types
- Migration support (Alembic)
- Relationship management

Database Initialization:
1. app.py calls db.init_db()
2. Checks if tables exist
3. Creates tables if missing (CREATE TABLE IF NOT EXISTS)
4. Creates default admin user if missing
5. Application ready for requests

================================================================================
3. TECHNOLOGY STACK
================================================================================

FRONTEND TECHNOLOGIES:
┌─────────────────────────────────────────┐
│ React 18.2 - UI Framework               │
│ TypeScript - Type Safety                │
│ Vite 5 - Build Tool                     │
│ Tailwind CSS - Styling                  │
│ Shadcn/ui - Components                  │
│ TanStack Query - Data Fetching          │
│ React Router v6 - Navigation            │
│ Axios - HTTP Client                     │
│ Lucide React - Icons                    │
│ Sonner - Notifications                  │
│ Radix UI - Accessible Components        │
└─────────────────────────────────────────┘

BACKEND TECHNOLOGIES:
┌─────────────────────────────────────────┐
│ FastAPI - Web Framework                 │
│ Uvicorn - ASGI Server                   │
│ SQLAlchemy 2.0 - ORM                    │
│ Pydantic 2.0 - Validation               │
│ python-jose - JWT Tokens                │
│ passlib - Password Hashing              │
│ bcrypt - Encryption                     │
│ Python-multipart - Form Handling        │
│ python-dotenv - Environment Variables   │
│ SQLite/Azure SQL - Database             │
└─────────────────────────────────────────┘

VERSION COMPATIBILITY:
Node.js: v18+ (v20 recommended)
Python: v3.11+ (v3.12 supported)
npm: v9+
pip: v22+

Key Dependencies:
Frontend package.json:
- react@18.2.0
- react-dom@18.2.0
- typescript@5.3.0
- vite@5.4.21
- tailwindcss@3.4.1
- @radix-ui/*@latest
- axios@1.6.0
- @tanstack/react-query@5.25.0
- react-router-dom@6.20.0
- sonner@1.2.0
- lucide-react@0.294.0

Backend requirements.txt:
- fastapi==0.104.1
- uvicorn==0.24.0
- sqlalchemy==2.0.23
- pydantic==2.5.0
- python-jose==3.3.0
- passlib==1.7.4
- python-multipart==0.0.6
- python-dotenv==1.0.0
- pyodbc==4.0.39 (for Azure SQL)

================================================================================
4. DATA MODELS & DATABASE SCHEMA
================================================================================

USER MODEL:
┌────────────────────────────────────────────────┐
│ Users Table                                    │
├────────────────────────────────────────────────┤
│ id (UUID, PK)                                  │
│ email (String(255), Unique, NotNull)           │
│ password_hash (String(255), NotNull)           │
│ display_name (String(255), Nullable)           │
│ tagline (String(500), Nullable)                │
│ bio (Text, Nullable)                           │
│ avatar_url (String(1024), Nullable)            │
│ role (String(50), Default='user')              │
│ is_protected (Boolean, Default=False)          │
│ created_at (DateTime, Default=Now)             │
│ updated_at (DateTime, Default=Now)             │
└────────────────────────────────────────────────┘

User Fields Explanation:
- id: Unique identifier (UUID v4), never changes
- email: Used for login, must be unique
- password_hash: Bcrypt hash of password (never store plain text)
- display_name: Full name for UI display
- tagline: Short bio/title
- bio: Longer description
- avatar_url: Profile picture URL
- role: 'admin' (system manager) or 'user' (regular)
- is_protected: If true, cannot be deleted (admin safety)
- created_at: Registration timestamp
- updated_at: Last modification timestamp

Password Hashing (Bcrypt):
1. User enters password: "MySecure123"
2. Bcrypt generates salt (random 16 bytes)
3. Hash = bcrypt.hash(password, salt)
4. Storage: $2b$10$abcdef... (104 characters)
5. Verification: bcrypt.verify(input, stored_hash)
6. Cannot reverse-engineer password from hash
7. Different hash every time (due to random salt)

Indexes for Performance:
- email: Indexed (unique constraint)
- role: Indexed (filter by role)
- created_at: Indexed (sort by date)
- is_protected: Indexed (find protected users)

Sample User Data:
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "john@example.com",
  "password_hash": "$2b$10$EIZxVpJT...",
  "display_name": "John Doe",
  "tagline": "Senior DevOps Engineer",
  "bio": "Managing cloud infrastructure",
  "avatar_url": "https://example.com/avatar.jpg",
  "role": "user",
  "is_protected": false,
  "created_at": "2025-11-20T10:00:00Z",
  "updated_at": "2025-11-25T15:30:00Z"
}

─────────────────────────────────────────────────

RESOURCE MODEL:
┌────────────────────────────────────────────────┐
│ Resources Table                                │
├────────────────────────────────────────────────┤
│ id (Integer, PK, AutoIncrement)                │
│ user_id (String(36), FK → users.id)            │
│ icon (String(50), NotNull)                     │
│ title (String(255), NotNull)                   │
│ resource_name (String(255), NotNull)           │
│ description (Text, Nullable)                   │
│ status (String(50), Nullable)                  │
│ region (String(100), Nullable)                 │
│ created_at (DateTime, Default=Now)             │
│ updated_at (DateTime, Default=Now)             │
└────────────────────────────────────────────────┘

Resource Fields Explanation:
- id: Auto-increment integer, unique per resource
- user_id: Foreign key to users table (who owns it)
- icon: Icon name ('server', 'database', etc.)
- title: Display title ("Web Server 1")
- resource_name: Internal identifier ("web-server-01")
- description: Detailed description
- status: 'Running', 'Stopped', 'Pending'
- region: Geographic location
- created_at: When resource was created
- updated_at: Last modification

Icon Options (18 available):
- server: Virtual machines
- database: SQL databases
- storage (hard_drive): Storage accounts
- network: Virtual networks
- key: Key vaults
- container: Container registries
- globe: Web apps
- link: Subdomains
- box: General containers
- folder: Storage/backups
- cloud: Cloud services
- shield: Firewalls
- zap: Load balancers
- activity: CDN/Front Door
- cpu: Function apps
- boxes: App services
- folder_open: Resource groups
- lock: Private endpoints

Status Options:
- Running: Resource active and operational
- Stopped: Resource inactive/deallocated
- Pending: Resource provisioning

Sample Resource Data:
{
  "id": 42,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "icon": "server",
  "title": "Web Server Production",
  "resource_name": "web-prod-01",
  "description": "Main production web server in East US",
  "status": "Running",
  "region": "East US",
  "created_at": "2025-11-20T10:30:00Z",
  "updated_at": "2025-11-25T14:15:00Z"
}

Relationships:
- One user → Many resources (1:N)
- If user deleted → All resources deleted (CASCADE)
- Each resource belongs to exactly one user
- User can view only own resources (except admin)

Indexes:
- user_id: Indexed (fast user resource lookup)
- status: Indexed (filter by status)
- created_at: Indexed (sort by date)

─────────────────────────────────────────────────

THEME MODEL:
┌────────────────────────────────────────────────┐
│ Themes Table                                   │
├────────────────────────────────────────────────┤
│ id (Integer, PK, AutoIncrement)                │
│ user_id (String(36), FK → users.id, Unique)    │
│ mode (String(20), Default='light')             │
│ primary_color (String(7), Nullable)            │
│ created_at (DateTime, Default=Now)             │
│ updated_at (DateTime, Default=Now)             │
└────────────────────────────────────────────────┘

Theme Fields:
- id: Unique identifier
- user_id: User who owns this theme (one per user)
- mode: 'light' or 'dark'
- primary_color: Hex color (#FF0000 format)
- created_at: When theme was created
- updated_at: Last modification

Sample Theme Data:
{
  "id": 5,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "mode": "dark",
  "primary_color": "#3B82F6",
  "created_at": "2025-11-20T10:30:00Z",
  "updated_at": "2025-11-25T14:15:00Z"
}

================================================================================
5. API SPECIFICATIONS
================================================================================

AUTHENTICATION ENDPOINTS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

POST /api/auth/register
Description: Register new user
Method: POST
Content-Type: application/json

Request Body:
{
  "email": "newuser@example.com",
  "password": "SecurePass123"
}

Response (201 Created):
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "newuser@example.com",
    "display_name": null,
    "role": "user"
  }
}

Error Responses:
400: {
  "detail": "Email already registered"
}
400: {
  "detail": "Password must be at least 8 characters"
}

─────────────────────────────────────────────────

POST /api/auth/login
Description: Authenticate user and get JWT token
Method: POST
Content-Type: application/json

Request Body:
{
  "email": "user@example.com",
  "password": "SecurePass123"
}

Response (200 OK):
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "user": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "display_name": "John Doe",
    "role": "user"
  }
}

Error Responses:
401: {
  "detail": "Invalid email or password"
}
404: {
  "detail": "User not found"
}

JWT Token Structure:
Header: {
  "alg": "HS256",
  "typ": "JWT"
}

Payload: {
  "sub": "550e8400-e29b-41d4-a716-446655440000",
  "exp": 1732470600,
  "iat": 1732466000
}

Signature: HMAC-SHA256(base64(header).base64(payload), SECRET_KEY)

Token Expiration: 30 minutes
Token Type: Bearer
Storage: Memory (not localStorage for XSS protection)
Sent: Authorization: Bearer <token>

─────────────────────────────────────────────────

USER ENDPOINTS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GET /api/users/me
Description: Get current user profile
Authentication: Required (JWT token)

Request Headers:
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

Response (200 OK):
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "display_name": "John Doe",
  "tagline": "Senior Engineer",
  "bio": "Cloud specialist",
  "avatar_url": "https://example.com/avatar.jpg",
  "role": "user",
  "is_protected": false,
  "created_at": "2025-11-20T10:00:00Z"
}

Error Responses:
401: {
  "detail": "Not authenticated"
}
403: {
  "detail": "Access token expired"
}

─────────────────────────────────────────────────

PUT /api/users/me
Description: Update current user profile
Authentication: Required
Method: PUT

Request Body:
{
  "display_name": "John Doe",
  "tagline": "Senior DevOps Engineer",
  "bio": "Managing cloud infrastructure with 5+ years experience",
  "avatar_url": "https://example.com/avatar.jpg"
}

Response (200 OK):
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "display_name": "John Doe",
  "tagline": "Senior DevOps Engineer",
  "bio": "Managing cloud infrastructure with 5+ years experience",
  "avatar_url": "https://example.com/avatar.jpg",
  "role": "user"
}

─────────────────────────────────────────────────

GET /api/users
Description: Get all users (Admin only)
Authentication: Required + Admin role

Request Headers:
Authorization: Bearer <admin_token>

Response (200 OK):
[
  {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "user@example.com",
    "display_name": "John Doe",
    "role": "user",
    "is_protected": false,
    "created_at": "2025-11-20T10:00:00Z"
  },
  {
    "id": "660e8400-e29b-41d4-a716-446655440001",
    "email": "admin@example.com",
    "display_name": "Admin User",
    "role": "admin",
    "is_protected": true,
    "created_at": "2025-11-01T00:00:00Z"
  }
]

Error Responses:
401: {
  "detail": "Not authenticated"
}
403: {
  "detail": "Only admins can view all users"
}

─────────────────────────────────────────────────

PUT /api/users/{user_id}/role
Description: Change user role (Admin only)
Authentication: Required + Admin role
Method: PUT

Request Body:
{
  "role": "admin"
}

Response (200 OK):
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "email": "user@example.com",
  "display_name": "John Doe",
  "role": "admin"
}

Error Responses:
403: {
  "detail": "Cannot modify protected users"
}
404: {
  "detail": "User not found"
}

─────────────────────────────────────────────────

DELETE /api/users/{user_id}
Description: Delete user (Admin only, cannot delete protected)
Authentication: Required + Admin role
Method: DELETE

Request Headers:
Authorization: Bearer <admin_token>

Response (200 OK):
{
  "success": true,
  "message": "User deleted successfully"
}

Error Responses:
403: {
  "detail": "Cannot delete protected users"
}
404: {
  "detail": "User not found"
}

Data Cascade:
- User deleted → All resources deleted
- User deleted → Theme deleted
- Orphaned data automatically cleaned up

─────────────────────────────────────────────────

RESOURCE ENDPOINTS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GET /api/resources
Description: List resources for current user
Authentication: Required

Query Parameters (Optional):
?status=Running
?region=East+US
?sort=created_at
?limit=10

Response (200 OK):
[
  {
    "id": 1,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "icon": "server",
    "title": "Web Server",
    "resource_name": "web-01",
    "description": "Production web server",
    "status": "Running",
    "region": "East US",
    "created_at": "2025-11-20T10:30:00Z",
    "updated_at": "2025-11-25T14:15:00Z"
  }
]

─────────────────────────────────────────────────

POST /api/resources
Description: Create new resource
Authentication: Required
Method: POST

Request Body:
{
  "icon": "server",
  "title": "API Server",
  "resource_name": "api-server-01",
  "description": "API backend server",
  "status": "Running",
  "region": "East US"
}

Response (201 Created):
{
  "id": 42,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "icon": "server",
  "title": "API Server",
  "resource_name": "api-server-01",
  "description": "API backend server",
  "status": "Running",
  "region": "East US",
  "created_at": "2025-11-25T15:30:00Z",
  "updated_at": "2025-11-25T15:30:00Z"
}

Validation Rules:
- icon: Required, must be valid icon name
- title: Required, 1-255 characters
- resource_name: Required, 1-255 characters
- status: Valid values (Running, Stopped, Pending)
- region: Valid Azure/AWS region

─────────────────────────────────────────────────

PUT /api/resources/{resource_id}
Description: Update resource
Authentication: Required (must be owner or admin)
Method: PUT

Request Body (all optional):
{
  "icon": "database",
  "title": "Updated Title",
  "status": "Stopped"
}

Response (200 OK):
{
  "id": 42,
  "title": "Updated Title",
  "icon": "database",
  "status": "Stopped",
  "updated_at": "2025-11-25T15:35:00Z"
}

Error Responses:
404: {
  "detail": "Resource not found"
}
403: {
  "detail": "You don't have permission to update this resource"
}

─────────────────────────────────────────────────

DELETE /api/resources/{resource_id}
Description: Delete resource
Authentication: Required (must be owner or admin)
Method: DELETE

Response (200 OK):
{
  "success": true,
  "message": "Resource deleted successfully"
}

Error Responses:
404: {
  "detail": "Resource not found"
}
403: {
  "detail": "You don't have permission to delete this resource"
}

─────────────────────────────────────────────────

THEME ENDPOINTS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GET /api/theme
Description: Get user theme preferences
Authentication: Required

Response (200 OK):
{
  "id": 5,
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "mode": "dark",
  "primary_color": "#3B82F6",
  "created_at": "2025-11-20T10:30:00Z",
  "updated_at": "2025-11-25T14:15:00Z"
}

─────────────────────────────────────────────────

PUT /api/theme
Description: Update theme preferences
Authentication: Required
Method: PUT

Request Body:
{
  "mode": "light",
  "primary_color": "#EF4444"
}

Response (200 OK):
{
  "id": 5,
  "mode": "light",
  "primary_color": "#EF4444",
  "updated_at": "2025-11-25T15:40:00Z"
}

Valid Color Formats:
- #RRGGBB (hex color)
- Examples: #FF0000, #00FF00, #0000FF

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

HEALTH CHECK ENDPOINT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GET /api/health
Description: Check API and database status
No Authentication Required

Response (200 OK):
{
  "status": "ok",
  "timestamp": "2025-11-25T15:45:00Z",
  "database": "connected",
  "uptime": 3600
}

Response (503 Service Unavailable):
{
  "status": "error",
  "message": "Database connection failed"
}

================================================================================
6. AUTHENTICATION & AUTHORIZATION FLOW
================================================================================

COMPLETE AUTHENTICATION FLOW:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. USER REGISTRATION:
   ├─ User enters email & password on registration page
   ├─ Frontend validates: email format, password length
   ├─ POST to /api/auth/register
   │  └─ Backend validates email not already registered
   │  └─ Hash password with bcrypt
   │  └─ Create user record in database
   │  └─ Generate JWT token
   ├─ Frontend receives token
   ├─ Token stored in memory (React state)
   └─ Redirect to dashboard

2. USER LOGIN:
   ├─ User enters email & password on login page
   ├─ POST to /api/auth/login
   │  └─ Backend finds user by email
   │  └─ Verify password hash matches
   │  └─ Generate JWT token (expires in 30 min)
   ├─ Frontend receives token
   ├─ Store token in memory + React Context
   ├─ Set auth header for all API requests
   └─ Redirect to dashboard

3. TOKEN USAGE IN REQUESTS:
   ├─ Frontend needs to access protected resource
   ├─ Include token in Authorization header:
   │  └─ Authorization: Bearer eyJhbGciOiJ...
   ├─ Backend receives request
   ├─ Extract token from header
   ├─ Verify signature using SECRET_KEY
   ├─ Check expiration time
   ├─ Extract user_id from token payload
   ├─ Load user from database
   └─ Process request with user context

4. TOKEN EXPIRATION & LOGOUT:
   ├─ Token expires after 30 minutes
   ├─ Next request fails with 401 Unauthorized
   ├─ Frontend catches 401 error
   ├─ Redirect user to login page
   ├─ Clear token from memory
   ├─ User logs in again with new token

JWT TOKEN STRUCTURE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Token = Header.Payload.Signature

HEADER:
{
  "alg": "HS256",         # Algorithm
  "typ": "JWT"            # Type
}

PAYLOAD (Claims):
{
  "sub": "550e8400...",   # Subject (user_id)
  "exp": 1732470600,      # Expiration timestamp
  "iat": 1732466000       # Issued at timestamp
}

SIGNATURE:
HMAC-SHA256(
  base64(header) + "." + base64(payload),
  SECRET_KEY
)

Example Full Token:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiI1NTBlODQwMC1lMjliLTQxZDQtYTcxNi00NDY2NTU0NDAwMDAiLCJleHAiOjE3MzI0NzA2MDAsImlhdCI6MTczMjQ2NjAwMH0.
xV6gd7q9zK3mL2nOpRsT...

ROLE-BASED ACCESS CONTROL (RBAC):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

User Roles:
┌─────────┬──────────────────────────────────┐
│ Role    │ Permissions                      │
├─────────┼──────────────────────────────────┤
│ user    │ - View own profile               │
│         │ - Create own resources           │
│         │ - Edit own resources             │
│         │ - Delete own resources           │
│         │ - Change own theme               │
│         │ - Cannot access admin panel      │
│         │ - Cannot manage users            │
├─────────┼──────────────────────────────────┤
│ admin   │ - All user permissions PLUS:     │
│         │ - View all users                 │
│         │ - Change user roles              │
│         │ - Delete any user (except self)  │
│         │ - Access admin panel             │
│         │ - System-wide visibility         │
└─────────┴──────────────────────────────────┘

Authorization Checks in Backend:

1. Route Protection:
@router.get("/api/admin/users")
async def get_all_users(
    current_user: User = Depends(get_current_user)
):
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Admin only")
    # Process request

2. Resource Ownership:
@router.put("/api/resources/{resource_id}")
async def update_resource(
    resource_id: int,
    current_user: User = Depends(get_current_user)
):
    resource = db.get_resource(resource_id)
    if resource.user_id != current_user.id and current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Not authorized")
    # Update resource

3. Protected User Check:
@router.delete("/api/users/{user_id}")
async def delete_user(
    user_id: str,
    current_user: User = Depends(get_current_user)
):
    target_user = db.get_user(user_id)
    if target_user.is_protected:
        raise HTTPException(status_code=403, detail="Cannot delete protected users")
    # Delete user

SECURITY CONSIDERATIONS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Password Security:
✓ Minimum 8 characters required
✓ Hashed with bcrypt (10 salt rounds)
✓ Never stored in plain text
✓ New hash generated each registration (due to random salt)
✓ Cannot reverse-engineer password from hash
✓ Server-side validation (not just client-side)

Token Security:
✓ Stored in memory (not localStorage or sessionStorage)
✓ Prevents XSS attacks (JavaScript cannot access)
✓ 30-minute expiration for session security
✓ Signature verification prevents tampering
✓ HTTPS only in production (prevent MITM attacks)

CORS Security:
✓ Only allows requests from configured origins
✓ Prevents unauthorized cross-origin access
✓ Credentials required for sensitive operations
✓ Preflight checks for complex requests

SQL Injection Prevention:
✓ SQLAlchemy parameterized queries
✓ No string concatenation in SQL
✓ ORM layer escapes all values
✓ Pydantic validates input types

XSS Prevention:
✓ React escapes HTML by default
✓ No innerHTML usage (using textContent)
✓ Sanitized user input
✓ Content Security Policy headers

Protected Admin Account:
✓ Default admin (ritesh@apka.bhai) cannot be deleted
✓ is_protected = TRUE in database
✓ Cannot be demoted from admin role
✓ Ensures system always has administrator
✓ Protects against accidental system lockout

================================================================================
7. FRONTEND ARCHITECTURE
================================================================================

COMPONENT HIERARCHY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

App (Root Component)
├── AuthContext Provider (Authentication State)
├── QueryClientProvider (Data Fetching)
├── Toaster (Notifications)
└── Router
    ├── Routes
    │   ├── / (Home/Dashboard)
    │   │   └─ Dashboard Component
    │   │       ├─ ResourceStats
    │   │       ├─ WelcomeMessage
    │   │       └─ QuickActions
    │   ├── /resources (Resource Management)
    │   │   └─ Resources Component
    │   │       ├─ ResourceList
    │   │       ├─ ResourceCard
    │   │       └─ ResourceModal
    │   ├── /user-management (Admin Panel)
    │   │   └─ UserManagement Component
    │   │       ├─ UserList
    │   │       ├─ UserCard
    │   │       └─ RoleDropdown
    │   ├── /settings (Profile & Theme)
    │   │   └─ Settings Component
    │   │       ├─ ProfileForm
    │   │       ├─ ThemeToggle
    │   │       └─ ResourceForm
    │   ├── /login (Authentication)
    │   │   └─ Login Component
    │   │       └─ LoginForm
    │   └── /register (Registration)
    │       └─ Register Component
    │           └─ RegisterForm
    │
    └── PrivateRoute (Protection)
        └─ Redirects to /login if not authenticated

KEY COMPONENTS:

1. AuthContext.tsx
Purpose: Global authentication state
Features:
- Store JWT token
- Store user information
- Login/logout functions
- Profile refresh
- Auto-redirect to login on 401

Provider Structure:
<AuthContext.Provider value={{ user, token, login, logout, ... }}>
  All child components can access auth state via useAuth() hook

2. Layout.tsx
Purpose: Common UI structure
Includes:
- Navigation sidebar
- Header with theme toggle
- Main content area
- Footer

3. Page Components (pages/)
- Dashboard.tsx: Overview & statistics
- Resources.tsx: Resource list & CRUD
- UserManagement.tsx: Admin user management
- Settings.tsx: Profile & theme settings
- Login.tsx: Login form
- Register.tsx: Registration form

STATE MANAGEMENT:

Client State (React Context):
├── Authentication
│   ├─ user (current user object)
│   ├─ token (JWT token)
│   ├─ isLoading (during auth operations)
│   └─ error (auth errors)
│
└── Theme
    ├─ mode (light/dark)
    └─ primaryColor (hex)

Server State (TanStack Query):
├── resources (useQuery)
├── users (useQuery)
├── theme (useQuery)
└── Mutations (useMutation)
    ├─ createResource
    ├─ updateResource
    ├─ deleteResource
    ├─ updateUserRole
    └─ deleteUser

Data Flow Example (Create Resource):

1. User fills form in Resources page
2. User clicks "Save"
3. Frontend validates form
4. useMutation sends POST to /api/resources
5. Backend validates data
6. Backend saves to database
7. Backend returns created resource
8. Frontend updates cache via QueryClient
9. Resource list re-renders with new data
10. Toast notification shows success

HOOKS USED:

React Hooks:
- useState: Local component state
- useEffect: Side effects (load data on mount)
- useCallback: Memoize functions
- useContext: Access context values

Custom Hooks:
- useAuth: Access authentication state
- useToast: Show notifications

TanStack Query Hooks:
- useQuery: Fetch & cache data
- useMutation: Create/update/delete operations
- useQueryClient: Manual cache management

React Router Hooks:
- useNavigate: Programmatic navigation
- useParams: Get URL parameters
- useLocation: Get current route

STYLING APPROACH:

Tailwind CSS:
- Utility-first framework
- Classes: flex, items-center, gap-4, etc.
- Responsive: sm:, md:, lg: prefixes
- Dark mode: dark: prefix
- Custom theme colors defined in tailwind.config.ts

Theme Implementation:
1. CSS Variables stored in :root element
2. Dark mode class applied to <html> element
3. Tailwind utilities automatically switch colors
4. User preference saved to database
5. Persists across page reloads

Example Component Styling:
<div className="flex flex-col md:flex-row gap-4 p-6">
  {/* flex: display: flex
      flex-col: flex-direction: column
      md:flex-row: on medium screens, flex-direction: row
      gap-4: gap: 1rem (16px)
      p-6: padding: 1.5rem (24px)
  */}
</div>

RESPONSIVE DESIGN:

Breakpoints:
- xs: 0px (mobile)
- sm: 640px (tablet small)
- md: 768px (tablet)
- lg: 1024px (desktop)
- xl: 1280px (desktop large)
- 2xl: 1536px (desktop XL)

Mobile-First Approach:
- Write styles for mobile first
- Use sm:, md:, lg: for larger screens
- Example:
  className="text-sm md:text-base lg:text-lg"
  // Mobile: small text, Desktop: large text

Touch Optimization:
- Tap targets: 44px minimum (accessibility)
- Spacing: Increased gaps on mobile
- Buttons: Full-width on mobile, auto on desktop
- Lists: Single column on mobile, multi-column on desktop

BUILD PROCESS:

npm run dev:
1. Vite starts dev server on :5000
2. Establishes HMR WebSocket connection
3. Watches file changes
4. Auto-refresh in browser on change
5. Source maps for debugging

npm run build:
1. TypeScript compilation (tsc)
   └─ Checks types, generates no output
2. Vite build (production bundle)
   ├─ Minification & tree-shaking
   ├─ Code splitting
   ├─ Asset optimization
   └─ Output: dist/public/
3. Result: index.html + CSS + JS files

Output Files (dist/public/):
- index.html (entry point)
- assets/index-xxxx.css (minified styles)
- assets/index-xxxx.js (minified code)
- Other assets (images, fonts)

================================================================================
8. BACKEND ARCHITECTURE
================================================================================

FASTAPI APPLICATION STRUCTURE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

app/main.py (FastAPI Application Setup):

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

# Create FastAPI app instance
app = FastAPI(
    title="Resource Management Dashboard",
    version="1.0.0",
    description="API for managing cloud resources"
)

# Configure CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=SETTINGS.cors_allowed_origins,  # e.g., ["http://localhost:5000"]
    allow_credentials=True,
    allow_methods=["*"],  # GET, POST, PUT, DELETE, OPTIONS
    allow_headers=["*"],  # Authorization, Content-Type, etc.
)

# Include routers
app.include_router(auth.router, prefix="/api/auth", tags=["auth"])
app.include_router(users.router, prefix="/api/users", tags=["users"])
app.include_router(resources.router, prefix="/api/resources", tags=["resources"])
app.include_router(theme.router, prefix="/api/theme", tags=["theme"])

# Middleware execution order:
# Request → CORS → Auth → Route Handler → Response

REQUEST LIFECYCLE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. HTTP Request arrives
   └─ POST /api/resources
      └─ Authorization: Bearer token
      └─ Content: { "icon": "server", "title": "..." }

2. CORS Middleware processes
   └─ Check if origin is allowed
   └─ Set CORS headers
   └─ Handle preflight if needed

3. Request routing
   └─ Match request method & path
   └─ Find appropriate router function

4. Dependency injection
   └─ get_current_user() executed
   └─ Extract token from header
   └─ Verify token signature
   └─ Load user from database
   └─ Inject user into handler

5. Request handler execution
   └─ Pydantic validates request body
   └─ Perform business logic
   └─ Database operations
   └─ Return response

6. Response processing
   └─ Serialize to JSON
   └─ Add response headers
   └─ Return to client

DEPENDENCY INJECTION:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Purpose: Inject dependencies into route handlers
Benefits: DRY code, testability, security

Example:

from fastapi import Depends

def get_current_user(token: str = Header(...)) -> User:
    """
    Extract and validate JWT token
    Return current user object
    """
    payload = jwt.decode(token, SECRET_KEY)
    user_id = payload.get("sub")
    user = db.get_user(user_id)
    return user

@router.get("/api/resources")
async def list_resources(
    current_user: User = Depends(get_current_user)
):
    """
    This route requires authentication
    current_user automatically injected
    """
    resources = db.get_user_resources(current_user.id)
    return resources

PYDANTIC VALIDATION:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Purpose: Validate request/response data
Automatic conversion & validation

Request Schema Example:

from pydantic import BaseModel, EmailStr, Field

class UserCreate(BaseModel):
    email: EmailStr  # Must be valid email
    password: str = Field(..., min_length=8, max_length=255)

    class Config:
        example = {
            "email": "user@example.com",
            "password": "SecurePass123"
        }

Validation Rules:
- type checking (str, int, etc.)
- min_length, max_length
- regex patterns
- custom validators
- nested models
- optional fields

Validation Flow:
1. Request received: {"email": "test", "password": "short"}
2. Pydantic parses request body
3. Type validation: is email a string? YES
4. EmailStr validation: is it valid email format? NO
5. Return 422 Unprocessable Entity with error details
6. If valid: Create UserCreate instance, pass to handler

ERROR HANDLING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

HTTP Status Codes:
- 200: Success
- 201: Created
- 204: No Content
- 400: Bad Request (validation failed)
- 401: Unauthorized (auth required)
- 403: Forbidden (insufficient permissions)
- 404: Not Found
- 422: Unprocessable Entity (invalid data)
- 500: Internal Server Error

Error Responses:

Validation Error (400):
{
  "detail": [
    {
      "loc": ["body", "email"],
      "msg": "invalid email format",
      "type": "value_error"
    }
  ]
}

Auth Error (401):
{
  "detail": "Not authenticated"
}

Permission Error (403):
{
  "detail": "Insufficient permissions"
}

Database Operations:

SQLAlchemy Query Examples:

# Create
new_user = User(email="test@example.com", ...)
db.session.add(new_user)
db.session.commit()

# Read
user = db.session.query(User).filter(User.email == email).first()

# Update
user.display_name = "New Name"
db.session.commit()

# Delete
db.session.delete(user)
db.session.commit()

Transactions:
- Atomic: All-or-nothing
- If error: Automatic rollback
- Prevent partial updates
- Ensure data consistency

DATABASE INITIALIZATION:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

On Application Startup:

1. Create engine (connection pool)
   └─ SQLite: local file or Azure SQL: server connection

2. Create tables
   └─ CREATE TABLE IF NOT EXISTS user (...)
   └─ CREATE TABLE IF NOT EXISTS resource (...)
   └─ CREATE TABLE IF NOT EXISTS theme (...)

3. Create default admin user
   └─ Check if admin exists
   └─ If not: Insert default admin
   └─ Email: ritesh@apka.bhai
   └─ Role: admin
   └─ is_protected: True

4. Create indexes
   └─ CREATE INDEX idx_user_email ON user(email)
   └─ CREATE INDEX idx_resource_user_id ON resource(user_id)

Performance Optimization:

Connection Pooling:
- Reuse database connections
- Reduce connection overhead
- Default: 5 connections per pool
- Max: 20 connections

Query Optimization:
- Use indexes on frequently searched fields
- Lazy vs eager loading relationships
- Avoid N+1 query problem
- SELECT only needed columns

Database Indexes:
- email: Unique index (fast lookup for login)
- user_id in resources: Fast user resource retrieval
- created_at: Fast sorting by date
- status: Fast filtering by status

LOGGING & MONITORING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Uvicorn Logging:
INFO: Application startup complete
INFO: Uvicorn running on http://0.0.0.0:8000
INFO: GET /api/health 200 OK

Log Levels:
- DEBUG: Detailed information for debugging
- INFO: General informational messages
- WARNING: Warning messages for potential issues
- ERROR: Error messages
- CRITICAL: Critical errors

Custom Logging Example:

import logging

logger = logging.getLogger(__name__)

@router.post("/api/auth/login")
async def login(credentials: LoginRequest):
    logger.info(f"Login attempt for {credentials.email}")
    try:
        user = authenticate(credentials)
        logger.info(f"Login successful for {credentials.email}")
        return generate_token(user)
    except Exception as e:
        logger.error(f"Login failed for {credentials.email}: {str(e)}")
        raise HTTPException(status_code=401)

================================================================================
9. DEPLOYMENT STRATEGIES
================================================================================

LOCAL DEVELOPMENT DEPLOYMENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Setup:
1. Clone repository
2. Install Node.js v20 & Python 3.11
3. Install dependencies
   frontend: npm install
   backend: pip install -r requirements.txt
4. Start servers
   frontend: npm run dev (port 5000)
   backend: python run.py (port 8000)
5. Open http://localhost:5000

Features:
- Hot Module Replacement (auto-refresh on change)
- SQLite database (auto-initialized)
- Debug mode enabled
- Development logging

Limitations:
- Single machine (no scaling)
- Not accessible from other machines
- No HTTPS
- Unsuitable for production

REPLIT DEPLOYMENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Replit is cloud IDE that can deploy applications

Setup:
1. Import repository to Replit
2. Configure Replit Secrets (env variables)
3. Setup workflows (dev servers)
4. Configure deployment
5. Publish/Deploy

Features:
- Cloud-hosted development environment
- Persistent storage
- Free tier available
- Built-in deployment
- Automatic HTTPS

Configuration:
- Replit secrets: API keys, database credentials
- Workflows: npm run dev, python run.py
- Deployment: Autoscale or VM

AZURE VM DEPLOYMENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Production-grade deployment on Azure infrastructure

Architecture:
┌──────────────────────────────────────────────┐
│ Frontend VM (Ubuntu 20.04)                   │
├──────────────────────────────────────────────┤
│ Nginx (reverse proxy, port 80)               │
│ → serves dist/public/ (static React files)   │
│ → proxies /api/* to Backend VM               │
└──────────────────────────────────────────────┘
         ↓
┌──────────────────────────────────────────────┐
│ Backend VM (Ubuntu 20.04)                    │
├──────────────────────────────────────────────┤
│ FastAPI (uvicorn, port 8000)                 │
│ → serves API endpoints                       │
│ → connects to Azure SQL                      │
└──────────────────────────────────────────────┘
         ↓
┌──────────────────────────────────────────────┐
│ Azure SQL Database                           │
├──────────────────────────────────────────────┤
│ Database: resource_dashboard                 │
│ Tables: users, resources, themes             │
│ Backups: Automatic (7-day retention)         │
└──────────────────────────────────────────────┘

Backend VM Setup:

1. Create Ubuntu 20.04 LTS VM (B2s: 2vCPU, 4GB RAM)
2. SSH into VM
3. Update system:
   sudo apt-get update && sudo apt-get upgrade -y

4. Install dependencies:
   sudo apt-get install -y python3.11 python3.11-venv
   curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
   sudo apt-get install -y nodejs

5. Clone repository:
   git clone https://github.com/username/resource-dashboard.git
   cd resource-dashboard/backend

6. Setup Python environment:
   python3.11 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt

7. Configure .env:
   cp .env.example .env
   nano .env
   (fill in Azure SQL credentials)

8. Create systemd service:
   sudo nano /etc/systemd/system/resource-dashboard.service
   
   [Unit]
   Description=Resource Dashboard API
   After=network.target

   [Service]
   Type=notify
   User=azureuser
   WorkingDirectory=/home/azureuser/resource-dashboard/backend
   ExecStart=/home/azureuser/resource-dashboard/backend/venv/bin/python run.py
   Restart=on-failure
   RestartSec=10

   [Install]
   WantedBy=multi-user.target

9. Enable and start service:
   sudo systemctl daemon-reload
   sudo systemctl enable resource-dashboard
   sudo systemctl start resource-dashboard
   sudo systemctl status resource-dashboard

Frontend VM Setup:

1. Create Ubuntu 20.04 LTS VM (B1s: 1vCPU, 1GB RAM)
2. SSH into VM
3. Update system:
   sudo apt-get update && sudo apt-get upgrade -y

4. Install dependencies:
   curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
   sudo apt-get install -y nodejs nginx

5. Clone and build:
   git clone https://github.com/username/resource-dashboard.git
   cd resource-dashboard/frontend
   npm install
   npm run build

6. Deploy to Nginx:
   sudo cp -r dist/public/* /var/www/html/
   sudo chown -R www-data:www-data /var/www/html

7. Configure Nginx:
   sudo nano /etc/nginx/sites-available/default
   
   Replace with:
   
   server {
       listen 80 default_server;
       root /var/www/html;

       location / {
           try_files $uri $uri/ /index.html;
           add_header Cache-Control "no-cache, no-store, must-revalidate";
       }

       location /api/ {
           proxy_pass http://BACKEND_VM_IP:8000/;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto $scheme;
       }
   }

8. Restart Nginx:
   sudo nginx -t
   sudo systemctl restart nginx

Azure SQL Setup:

1. Create SQL Server in Azure Portal
2. Create database: resource_dashboard
3. Run SQL scripts:
   - 01_create_tables.sql
   - 02_insert_default_data.sql
   - 03_create_admin_user.sql

4. Configure firewall:
   Allow Backend VM IP address
   Create firewall rule in SQL Server settings

SSL/TLS Setup:

1. Obtain certificate:
   sudo apt-get install -y certbot python3-certbot-nginx
   sudo certbot certonly --nginx -d yourdomain.com

2. Update Nginx config for HTTPS:
   server {
       listen 443 ssl http2 default_server;
       listen [::]:443 ssl http2 default_server;
       
       ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
       ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
       ssl_protocols TLSv1.2 TLSv1.3;
       
       # ... rest of config
   }
   
   # Redirect HTTP to HTTPS
   server {
       listen 80;
       server_name yourdomain.com;
       return 301 https://$server_name$request_uri;
   }

3. Auto-renew certificates:
   sudo certbot renew --dry-run

DEPLOYMENT CHECKLIST:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Infrastructure:
☐ VMs created (Backend, Frontend)
☐ Network configured (VNet, NSGs)
☐ Azure SQL database created
☐ Firewall rules configured

Backend VM:
☐ Dependencies installed
☐ Repository cloned
☐ .env configured with production values
☐ Python virtual environment created
☐ Systemd service created and enabled
☐ Service running and auto-restart configured
☐ Logs configured

Frontend VM:
☐ Dependencies installed
☐ Repository cloned
☐ Build completed successfully
☐ Files deployed to /var/www/html
☐ Nginx configured for API proxying
☐ Nginx running and auto-restart enabled

SSL/TLS:
☐ Certificate obtained
☐ HTTPS configured
☐ HTTP redirects to HTTPS
☐ Certificate auto-renewal configured

Database:
☐ Azure SQL server accessible
☐ Database created
☐ Tables created (SQL scripts run)
☐ Admin user created
☐ Backups configured
☐ Firewall allows Backend VM

Monitoring:
☐ Application logs enabled
☐ Database logs enabled
☐ Health check endpoint working
☐ Alerts configured

Security:
☐ Network security groups configured
☐ Passwords changed from defaults
☐ CORS origins updated
☐ Secret keys rotated
☐ Firewall rules minimal (least privilege)

================================================================================
10. PERFORMANCE & SCALABILITY
================================================================================

FRONTEND PERFORMANCE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Bundle Size Metrics:
- Total: 520KB (minified)
- Gzipped: 160KB
- CSS: 43KB (7.9KB gzipped)
- JavaScript: 518KB (160KB gzipped)

Performance Optimizations:
✓ Code splitting by route
✓ Lazy loading components
✓ Minification & uglification
✓ Tree-shaking (remove unused code)
✓ Image optimization
✓ CSS purging (remove unused styles)
✓ Gzip compression
✓ Browser caching

Load Time:
- First contentful paint (FCP): <1 second
- Largest contentful paint (LCP): <2 seconds
- Time to interactive (TTI): <2 seconds
- Total page load: <2-3 seconds on 3G

Caching Strategy:
- Browser cache: 1 year for assets (via .gitignore)
- API cache: TanStack Query (5 minutes default)
- Service worker (optional): Offline support
- CDN (optional): Geographic distribution

BACKEND PERFORMANCE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

API Response Times:
- Login: <100ms
- List resources: <50ms (small dataset)
- Create resource: <100ms
- Update resource: <100ms
- Delete resource: <100ms

Database Query Performance:
- SELECT queries: <10ms (with indexes)
- INSERT queries: <20ms
- UPDATE queries: <20ms
- DELETE queries: <20ms

Database Optimization:
✓ Indexes on frequently searched columns
✓ Connection pooling (5 connections)
✓ Query caching via SQLAlchemy
✓ Lazy loading relationships
✓ Batch operations where possible

Memory Usage:
- Backend process: ~100MB base
- Python interpreter: 20MB
- SQLAlchemy + ORM: 30MB
- Database connection pool: 20MB
- Query cache: 30MB

CPU Usage:
- Idle: <1% CPU
- Login request: 2-5% CPU spike
- Create resource: 1-3% CPU spike
- List resources: 1-2% CPU spike

Uvicorn Workers Configuration:
Development: 1 worker (single threaded)
Production: 4+ workers (multiprocessing)
Formula: Workers = (2 × CPU Cores) + 1
Example: 2-core VM = 5 workers

CONNECTION POOLING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Purpose: Reuse database connections
Benefits: Reduce connection overhead
Configuration:
pool_size = 5 (connections in pool)
max_overflow = 10 (extra connections if needed)
pool_recycle = 3600 (recycle after 1 hour)

Connection Lifecycle:
1. Create connection pool on app startup
2. Request arrives, get connection from pool
3. Execute query with connection
4. Return connection to pool
5. Connection available for next request
6. Max connections: pool_size + max_overflow = 15

DATABASE SCALABILITY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Current Scale:
- Users: 100+ users
- Resources: 10,000+ resources
- Requests/sec: 10-20 req/sec

Scalability Limitations:
- SQLite: Single writer at a time
- Single backend server
- No load balancing

Scaling Strategy 1: Vertical Scaling
- Upgrade VM (more CPU, RAM)
- Increase database tier
- More Uvicorn workers
- Suitable up to 100 users

Scaling Strategy 2: Horizontal Scaling
- Multiple backend VMs
- Load balancer (Azure Load Balancer)
- Azure SQL (handles concurrency)
- Read replicas for queries
- Suitable for 1000+ users

Scaling Strategy 3: Advanced Optimization
- Redis caching (session, query cache)
- Message queue (background jobs)
- CDN (static assets)
- Database sharding (by user_id)
- Microservices architecture

Recommended for 1000+ Users:
- 3+ backend servers (load balanced)
- Azure SQL (Standard tier minimum)
- Redis cache layer
- CDN for static files
- Monitoring & auto-scaling

================================================================================
11. SECURITY CONSIDERATIONS
================================================================================

AUTHENTICATION SECURITY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Password Storage:
✓ Bcrypt hashing (not MD5, SHA1)
✓ 10 salt rounds (computational cost)
✓ Unique salt per password (random)
✓ Never store plain text passwords
✓ Cannot reverse-engineer password

Password Requirements:
✓ Minimum 8 characters
✓ No maximum length
✓ Special characters not required (good UX)
✓ Server-side validation (not just frontend)

Example Hash Comparison:
Plain: "MySecure123"
Hash1: "$2b$10$abcdef1234567890..."
Hash2: "$2b$10$ghijkl0987654321..."
Both are same password but different hashes
Comparison: bcrypt.verify(plain, hash1) → TRUE

JWT Token Security:
✓ Signature verification (prevent tampering)
✓ Expiration time (30 minutes)
✓ Secret key (minimum 32 characters)
✓ HTTPS only (prevent MITM attacks)

Token Compromise:
If token stolen:
- Attacker can use token for 30 minutes
- Token expires automatically
- User logs in again with new token
- Old token becomes invalid

AUTHORIZATION SECURITY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Role-Based Access Control (RBAC):
✓ Admin role: Full system access
✓ User role: Limited to own resources
✓ Server-side enforcement (not client-side)
✓ Cannot bypass via JavaScript

Example Authorization Check:
GET /api/resources/42
Authorization: Bearer user_token

Backend:
1. Verify user authenticated
2. Load resource from database
3. Check: resource.user_id == current_user.id
4. If false: Return 403 Forbidden
5. If true: Return resource

Protected Admin Account:
✓ Cannot be deleted (is_protected = true)
✓ Cannot be demoted (role = "admin" always)
✓ Prevents system lockout
✓ Default admin email: ritesh@apka.bhai

DATA SECURITY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

SQL Injection Prevention:
✓ SQLAlchemy parameterized queries
✓ No string concatenation in SQL
✓ ORM layer escapes all values
✓ Type validation via Pydantic

Vulnerable Code (DON'T USE):
query = f"SELECT * FROM users WHERE email = '{email}'"
Attacker: email = "'; DROP TABLE users; --"
Result: All user data deleted

Safe Code (USED):
User.query.filter(User.email == email).first()
Pydantic validation ensures email is string
SQLAlchemy escapes value automatically

XSS (Cross-Site Scripting) Prevention:
✓ React escapes HTML by default
✓ No innerHTML usage (uses textContent)
✓ CSP headers (Content Security Policy)
✓ No eval() execution
✓ Sanitize user input

CSRF (Cross-Site Request Forgery) Prevention:
✓ SameSite cookies
✓ Double submit cookie pattern
✓ CORS same-origin validation
✓ Token-based validation

CORS (Cross-Origin Resource Sharing):
✓ Whitelist allowed origins
✓ Prevent unauthorized cross-origin requests
✓ Credentials flag enabled
✓ Preflight requests validated

Configuration:
allow_origins=["https://yourdomain.com"]  # Production
allow_origins=["*"]  # Development only

HTTPS/TLS:
✓ Encrypt data in transit
✓ Prevent man-in-the-middle attacks
✓ Certificate validation
✓ Force HTTPS (redirect HTTP)

Certificate Types:
- Self-signed: Development
- Let's Encrypt: Free, production
- Commercial CA: Premium, trusted everywhere

INFRASTRUCTURE SECURITY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Network Security:
✓ Virtual Private Network (VNet)
✓ Network Security Groups (firewalls)
✓ Private subnets (database)
✓ Public subnets (web servers)
✓ No direct internet database access

Firewall Rules (NSG):
Frontend VM (Public):
- Inbound: Port 80, 443 (HTTP/HTTPS) from anywhere
- Inbound: Port 22 (SSH) from admin IP only
- Outbound: All

Backend VM (Private):
- Inbound: Port 8000 from Frontend VM only
- Inbound: Port 22 (SSH) from admin IP only
- Outbound: Port 1433 (Azure SQL)

Database (Private):
- Inbound: Port 1433 from Backend VM only
- No internet access

SECRETS MANAGEMENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Secrets (Never in code):
✓ SECRET_KEY (JWT signing)
✓ Database passwords
✓ API keys
✓ Third-party credentials

Storage Options:
1. .env file (development only, .gitignored)
2. Environment variables (Replit Secrets, CI/CD)
3. Azure Key Vault (production)

Priority Order:
1. .env file (highest priority)
2. Environment variables
3. Code defaults (lowest priority)

Example .env (Never commit):
SECRET_KEY=your-super-secret-key-32-chars-minimum-here
AZURE_SQL_PASSWORD=YourDatabasePassword123!
AZURE_SQL_SERVER=your-server.database.windows.net

Never do this:
SECRET_KEY="hardcoded-in-code"  # ❌ SECURITY RISK
git add .env  # ❌ Secrets exposed in git history
console.log(API_KEY)  # ❌ Visible in browser

AUDIT LOGGING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Log Important Events:
✓ User login (success/failure)
✓ User registration
✓ Role changes (who, when, what)
✓ Resource creation/deletion (by whom)
✓ Failed authentication attempts
✓ Access control violations

Log Format:
[2025-11-25 15:30:00] INFO: User login: john@example.com
[2025-11-25 15:31:00] INFO: Resource created: id=42 by user john@example.com
[2025-11-25 15:32:00] ERROR: Failed login: admin@example.com (wrong password)

Log Storage:
- Centralized logging (Azure Monitor, ELK)
- Retention: 90 days minimum
- Immutable (prevent tampering)
- Searchable (for investigation)

SECURITY BEST PRACTICES:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Development:
✓ Use .env for secrets
✓ Never commit secrets
✓ Use random SECRET_KEY
✓ Enable debug logging
✓ Use SQLite for development

Production:
✓ Use environment variables
✓ Strong passwords (32+ characters)
✓ Regular backups
✓ Monitor logs for attacks
✓ Keep dependencies updated
✓ Rate limiting enabled
✓ Web Application Firewall (optional)

Regular Audits:
✓ Security dependencies check: npm audit
✓ Code review for vulnerabilities
✓ Penetration testing
✓ Update dependencies monthly

================================================================================
12. MONITORING & LOGGING
================================================================================

APPLICATION MONITORING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Metrics to Monitor:
1. Request Count
   - Total requests
   - Requests per endpoint
   - Requests per user
   - Trend analysis

2. Response Time
   - Average response time
   - P95/P99 response time
   - Slow requests
   - Response time by endpoint

3. Error Rate
   - HTTP 5xx errors (server)
   - HTTP 4xx errors (client)
   - Error rate percentage
   - Most common errors

4. Resource Usage
   - CPU usage
   - Memory usage
   - Disk usage
   - Network bandwidth

5. Database Performance
   - Query execution time
   - Connection pool usage
   - Query count
   - Slow queries

Health Check Endpoint:
GET /api/health
Response:
{
  "status": "ok",
  "timestamp": "2025-11-25T15:45:00Z",
  "database": "connected",
  "uptime": 3600
}

Alerts to Configure:
⚠️ CPU usage > 80%
⚠️ Memory usage > 90%
⚠️ Error rate > 5%
⚠️ Response time > 1000ms
⚠️ Database connection fails
⚠️ Disk usage > 85%

LOGGING STRATEGY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Log Levels:
DEBUG: Detailed debugging information
INFO: General informational messages
WARNING: Warning messages
ERROR: Error messages
CRITICAL: Critical system errors

Log Examples:

DEBUG Level:
[DEBUG] SQL Query: SELECT * FROM users WHERE id = '550e8400...'
[DEBUG] Query execution time: 5ms
[DEBUG] Parameter validation: email=john@example.com

INFO Level:
[INFO] Application startup complete
[INFO] User login: john@example.com
[INFO] Resource created: id=42 title="Web Server"
[INFO] Database connected: sqlite:///backend/data/app.db

WARNING Level:
[WARNING] Slow query detected: 250ms execution
[WARNING] Connection pool near capacity: 14/15
[WARNING] Failed login attempt: admin@example.com

ERROR Level:
[ERROR] Database connection failed: timeout
[ERROR] Invalid JWT token: signature mismatch
[ERROR] User not found: 550e8400-e29b-41d4-a716-446655440000

CRITICAL Level:
[CRITICAL] Database completely unavailable
[CRITICAL] Application crash: OutOfMemory
[CRITICAL] Secret key missing from configuration

Log Rotation:
- Keep current log file
- Archive old logs (gzip)
- Retention: 90 days
- Max file size: 100MB

Log Aggregation Tools:
Development: Simple file logging
Production: ELK Stack (Elasticsearch, Logstash, Kibana)
Production: Azure Monitor Logs
Production: Splunk
Production: DataDog

Example Logs Query (Kibana):
Show all errors in last 24 hours:
{"level": "ERROR"} AND timestamp > now-24h

================================================================================
13. DISASTER RECOVERY
================================================================================

BACKUP STRATEGY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Database Backups:

SQLite (Development):
- File-based backup: Copy app.db
- Frequency: Manual or before major changes
- Retention: Keep last 5 backups
- Storage: Separate disk/cloud

Azure SQL (Production):
- Automatic backups: 7-day retention
- Point-in-time restore: Available
- Geo-redundant: Multiple datacenters
- Manual backups: On-demand full copy

Backup Schedule:
- Hourly: Automated snapshots
- Daily: Full backup to Azure Storage
- Weekly: Archive backup (long-term)
- Monthly: Test restore procedure

Application Backups:
- Code repository (GitHub)
- .env configuration backup (encrypted)
- SSL certificates backup
- Database schema backup

DISASTER RECOVERY PLAN:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Scenarios:

1. Backend VM Crashes:
   ├─ Systemd auto-restart (configured)
   ├─ Service recovers within 10 seconds
   ├─ If not recovered: Manual restart
   └─ Manual: sudo systemctl restart resource-dashboard

2. Database Connection Fails:
   ├─ Application logs error
   ├─ Manual intervention: Check firewall rules
   ├─ Verify database server running
   └─ Restart database connection pool

3. Data Corruption:
   ├─ Stop application
   ├─ Restore from backup (point-in-time)
   ├─ Verify data integrity
   └─ Restart application

4. Security Breach:
   ├─ Immediate: Invalidate all tokens
   ├─ Change SECRET_KEY
   ├─ Reset all passwords
   ├─ Review audit logs
   ├─ Patch vulnerability
   └─ Force users to re-login

Recovery Time Objectives (RTO):
- Backend down: 5 minutes
- Database unavailable: 15 minutes
- Data corruption: 1 hour
- Security breach: 30 minutes

Recovery Point Objectives (RPO):
- Data loss tolerance: < 1 hour
- Backup frequency: Hourly

HIGH AVAILABILITY:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

For Production Deployment:

1. Load Balancer (Front)
   ├─ Distributes traffic
   ├─ Health checks
   ├─ Automatic failover
   └─ Sticky sessions for state

2. Multiple Backend Servers
   ├─ 2+ instances
   ├─ Stateless (no local storage)
   ├─ Synchronized time
   └─ Same .env configuration

3. Azure SQL HA
   ├─ Automatic failover
   ├─ Read replicas
   ├─ Geographic redundancy
   └─ Sync replication

4. Monitoring & Alerts
   ├─ Real-time alerts
   ├─ Auto-scale on demand
   ├─ Health dashboard
   └─ Incident response

Architecture:

┌─────────────────────────────────────────┐
│ Client Requests                         │
└────────────────┬────────────────────────┘
                 ↓
        ┌────────────────┐
        │ Load Balancer  │
        └────────────────┘
         ↙             ↘
   ┌─────────┐    ┌─────────┐
   │Backend1 │    │Backend2 │
   │ (8000)  │    │ (8000)  │
   └────┬────┘    └────┬────┘
        └────┬─────┬───┘
             ↓     ↓
        ┌──────────────┐
        │ Azure SQL    │
        │ (Primary)    │
        └──────────────┘
             ↓
        ┌──────────────┐
        │ Azure SQL    │
        │ (Replica)    │
        └──────────────┘

================================================================================
14. MAINTENANCE & TROUBLESHOOTING
================================================================================

COMMON ISSUES & SOLUTIONS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Issue 1: "Port 5000 already in use"
Cause: Another process using port
Solution:
lsof -i :5000  # Find process
kill -9 <PID>  # Kill process
Or use different port: npm run dev -- --port 5001

Issue 2: "Cannot find module 'react'"
Cause: Dependencies not installed
Solution:
cd frontend
npm install  # Install dependencies

Issue 3: "Backend API not responding"
Cause: Backend not running
Solution:
cd backend
python run.py  # Start backend

Issue 4: "Database connection failed"
Cause: SQLite not initialized
Solution:
# Restart backend (auto-initializes database)
python run.py
# Or manually: python backend/app/db/init_db.py

Issue 5: "Login fails - 401 Unauthorized"
Cause: Wrong credentials
Solution:
- Verify email/password correct
- Check admin user exists
- Reset admin password:
  python backend/app/db/super_user_seed.py

Issue 6: "CORS error - blocked by browser"
Cause: Frontend origin not in CORS list
Solution:
- Update CORS_ALLOW_ORIGINS in .env
- Include frontend domain
- Restart backend

Issue 7: "Resources don't appear on page"
Cause: Not logged in or API error
Solution:
- Verify login successful
- Check browser console (F12)
- Check backend logs
- Verify database has data

Issue 8: "Azure SQL connection failed"
Cause: Firewall or credentials wrong
Solution:
- Test connection: sqlcmd -S server.database.windows.net -U user
- Check firewall rule allows your IP
- Verify credentials in .env
- Check database exists

MAINTENANCE TASKS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Daily Tasks:
☐ Monitor error logs
☐ Check backup status
☐ Verify application responding

Weekly Tasks:
☐ Review performance metrics
☐ Check disk usage
☐ Verify backups working
☐ Update logs review

Monthly Tasks:
☐ Security audit
☐ Dependency updates: npm audit
☐ Database maintenance
☐ Disaster recovery test
☐ Review access logs

Quarterly Tasks:
☐ Load testing
☐ Security scan
☐ Capacity planning
☐ Cost optimization review

Annual Tasks:
☐ Architecture review
☐ Technology update assessment
☐ Compliance audit
☐ Disaster recovery drill

UPDATING & PATCHING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Update Schedule:
- Security patches: Immediate
- Bug fixes: Weekly
- Feature updates: Monthly
- Major version updates: Quarterly

Update Process:
1. Test in development environment
2. Review changes/release notes
3. Backup database
4. Disable notifications (optional)
5. Apply update
6. Run tests
7. Monitor for issues
8. Enable notifications

npm Package Updates:
# Check outdated packages
npm outdated

# Update all packages
npm update

# Update specific package
npm install react@latest

# Security audit
npm audit

Python Dependency Updates:
# Check outdated packages
pip list --outdated

# Update all packages
pip install --upgrade -r requirements.txt

# Update specific package
pip install --upgrade fastapi

# Security check
pip install safety
safety check

Git Operations:
# Pull latest code
git pull origin main

# Check branch status
git status

# Create backup branch
git checkout -b backup-before-update

# Return to main
git checkout main

PERFORMANCE TUNING:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

If application slow:

1. Check CPU usage:
   top  # Linux command
   Check if process > 80% CPU

2. Check memory usage:
   free -h  # Linux command
   Check if available memory > 20%

3. Check disk usage:
   df -h  # Linux command
   Check if usage > 85%

4. Check database performance:
   Query execution time
   Check for slow queries
   Verify indexes exist

5. Check network:
   Latency between servers
   Bandwidth usage
   Connection pool exhaustion

Optimization Actions:
- Add database indexes
- Increase Uvicorn workers
- Upgrade VM size
- Add Redis caching
- Enable CDN for static files
- Implement query pagination
- Archive old logs

ROLLBACK PROCEDURE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

If update causes issues:

1. Identify issue quickly
2. Stop application
3. Restore database from backup
4. Rollback code to previous version
5. Restart application
6. Verify working
7. Investigate root cause

Git Rollback:
# View commit history
git log --oneline

# Revert to previous commit
git revert <commit-hash>

# Or reset (if not pushed)
git reset --hard <commit-hash>

Database Rollback:
# Azure SQL
az sql db restore \
  --resource-group <group> \
  --server <server> \
  --name resource_dashboard \
  --time <timestamp>

# SQLite
cp backup/app.db.bak backend/data/app.db

================================================================================
END OF DOCUMENT
================================================================================

For additional support:
- GitHub Issues: Report bugs
- Documentation: See README.md
- Email: support@example.com

Last Updated: November 25, 2025
Version: 1.0.0
Status: Production Ready

================================================================================
